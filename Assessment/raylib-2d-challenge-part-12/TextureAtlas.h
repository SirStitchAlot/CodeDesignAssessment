/** PackedTexture.h
 *
 * Handles use of texture atlases (i.e., textures containing multiple images).
 *
 * @author Hans de Ruiter
 *
 * @copyright (c) 2023 by Kea Sigma Delta Limited, all rights reserved
 *
 * See License.txt for license.
 */

#include "raylib-cpp.hpp"

#include <memory>
#include <unordered_map>

class TASprite;
class TASpriteAnimation;
class TAFrame;

typedef std::unordered_map<std::string, TASprite> TASpriteMap;
typedef std::vector<TAFrame> TAFrameArray;

/** Handles textures containing an atlas of multiple sprites/images.
 *
 * You can use Raylib's Texture Packer (rTexPacker) to generate the atlas file:
 * https://raylibtech.itch.io/rtexpacker
 * 
 * The atlas has individual frames, which form multiple animations beloning to a
 * sprite. You can think of a sprite as a single character or object. To create
 * sprites with multiple animations, use the following sprite frame naming 
 * convention: <sprite-name>_<animation-name>_<frame-number>. For example,
 * frame 0 of the walking animation for rabbit would be: rabbit_walk_0. Do *NOT*
 * use underscores (i.e, "_") in object names. Use a dash ("-") instead.
 * 
 * The file format itslef is very simple. There's a header for the atlas info:
 * a <imagePath> <width> <height> <spriteCount> <isFont> <fontSize>
 * where:
 * - imagePath is the path to the texture
 * - width is the texture's width
 * - height is the texture's height
 * - spriteCount is the number of sprite frames in the texture
 * - isFont indicates if this is a font texture
 * - fontSize is the size of the font if isFont is true
 * 
 * This is followed by one or more "sprite" definitions:
 * s <nameId> <originX> <originY> <positionX> <positionY> 
 *     <sourceWidth> <sourceHeight> <padding> <trimmed> <trimRecX> <trimRecY> 
 *     <trimRecWidth> <trimRecHeight>
 * where:
 * - nameId - is the sprite frame name (using the naming convention above)
 * - originX/Y - the coordinate of the frame's origin relative to the frame's 
 *   top-left corner
 * - positionX/Y - the location of the frame's top-left corner in the texture
 * - sourceWidth/Height - the frame's original size in pixels
 * - padding - how many pixels of padding are inserted between frames
 * - trimmed - set to 1 if the frame has been trimmed to eliminate transparent
 *   areas. 0 if no trimming was done
 * - trimRecX/Y - the number of pixels that were trimmed off the left and top
 *   sides
 * - trimRecWidth/height - the width and height of the trimmed frame
 */
class TextureAtlas {
public:
	friend class TAFrame;

	/** Loads a texture atlas from file.
	 * You can use Raylib's Texture Packer (rTexPacker) to generate the atlas file:
	 * https://raylibtech.itch.io/rtexpacker
	 *
	 * @param atlasFileName the atlas file's name (or full path). This should 
	 * be in *.rtpa format (i.e., the format generated by rTexPacker).
	 * NOTE: The atlas file indicates which texture to load, so make sure that
	 */
	TextureAtlas(const std::string &atlasFileName);
	
	~TextureAtlas();
	
	/** Gets the list of sprites contained in this atlas.
	 * A sprite has a set of animations, and animation frames.
	 */
	const TASpriteMap& getSprites() const;
	
	/** Gets a sprite by name.
	 */
	const TASprite* getSprite(const std::string &name) const;
	
private:
	/** Parses an atlas file.
	 * 
	 * @param file the file to parse
	 * @param fileName the file's name
	 * 
	 * @throws std::runtime_error if the file could not be parsed 
	 */
	void parseAtlas(FILE *file, const std::string &fileName);

	/** Add a sprite frame to the atlas.
	 * 
	 * @param name the frame's name
	 * @param originX the x-axis origin within the frame
	 * @param originY the y-axis origin within the frame
	 * @param positionX the x-axis position of the frame within the texture
	 * @param positionY the y-axis position of the frame within the texture
	 * @param width the frame's width in pixels
	 * @param height the frame's height in pixels
	 * @param padding the number of pixels of padding around the frame
	 */
	void addSpriteFrame(const char *name, int originX, int originY, 
		unsigned positionX, unsigned positionY, unsigned width, unsigned height, unsigned padding);

	std::shared_ptr<raylib::Texture2D> texture;
	
	TASpriteMap sprites;
};

/** Stores sprite animations.
 */
class TASprite {
public:
	TASprite(); 

	/** This sprite's animations.
	 */
	std::unordered_map<std::string, TASpriteAnimation> animations;
	
	/** Gets a sprite animation by name.
	 */
	const TASpriteAnimation* getAnimation(const std::string &name) const;

	raylib::Vector2 size;
};

/** Stores a sprite animation.
 * 
 * NOTE: Use a TASpriteAnimationPlayer to play the animation.
 */
class TASpriteAnimation {
public:
	/** This animation's frames
	 */
	TAFrameArray frames;

	/** Draw a frame at the specified position.
	 * 
	 * NOTE: This must be called between BeginDraw() and EndDraw().
	 * 
	 * @param atlas the texture atlas
	 * @param frameNo the number of the frame to draw
	 * @param position the position
	 * @param scale the scale facto to draw at
	 */
	void drawFrame(const TextureAtlas &atlas, unsigned frameNo, const raylib::Vector2 &position, float scale) const;

	/** Gets the number of frames.
	 */
	unsigned getNumFrames() const;
};

/** An animation player for TASpriteAnimation.
 */
class TASpriteAnimationPlayer {
public:
	/** Constructs a new texture atlas sprite animation player.
	 * 
	 * @param textureAtlas the texture atlas containing the sprite
	 * @param animation the sprite animation to play
	 */
	TASpriteAnimationPlayer(std::shared_ptr<const TextureAtlas> textureAtlas, const TASpriteAnimation *animation);

	~TASpriteAnimationPlayer();

	/** Updates the animation.
	 * 
	 * @param elapsedTime the time since the last update
	 * @param loop set to true to loop the animation
	 * 
	 * @return bool true if the animation has finished, false otherwise
	 * NOTE: This will always be false if loop == true.
	 */
	bool update(float elapsedTime, bool loop = true);

	/** Draws the sprite with the current frame.
	 */
	void draw(const raylib::Vector2 &position, float scale);

private:
	std::shared_ptr<const TextureAtlas> textureAtlas;
	const TASpriteAnimation *animation;
    float frameDelay;
	float frameDelayCounter;
	unsigned frameIndex;
};

/** Handles a single sprite animation frame
 */
class TAFrame {
public:
	TAFrame();

	TAFrame(const raylib::Rectangle srcRegion, raylib::Vector2 origin);

	/** The frame's location in the atlas
	 */
	raylib::Rectangle srcRegion;

	/** The sprite's origin within the frame (relative to the top-left corner)
	 */
	raylib::Vector2 origin;

	/** Draws this frame at the specified position.
	 * 
	 * NOTE: This must be called between BeginDraw() and EndDraw().
	 * 
	 * @param atlas the texture atlas
	 * @param position the position
	 * @param scale the scale facto to draw at
	 */
	void draw(const TextureAtlas& atlas, const raylib::Vector2 &position, float scale) const;
};
